 
# Read 03

## Review

### Data Modeling & NoSQL Databases

1. Name 3 advantages to Test Driven Development?

Be up to date with any errors that might come up
Know exactly how your program work
Predict future scenarios


2. In what case would you need to use beforeEach() or afterEach() in a test suite?

First one, beforeEach() we run it before the test for description and sending the data to the test
Second one, afterEach() we run it after the test for finalizing the test, for example exiting the process
What is one downside of Test Driven Development?


3. What is one downside of Test Driven Development

Tedious task that takes alot of time.

4. What’s the primary difference between ES6 Classes and Constructor/Prototype Classes?

Basically ES6 do the same functionality but with a better cleaner code overall, it also helps in making the program run fast

5. Name a use case for a static method

Something consistent, like an age that increases every year.

6. Write an example of a Higher Order function and describe the use case it solves

A function that takes the sum of a range, this way it calls the sum but it needs to call a function of range first.

## Terms

functional programming: is the process of building software by composing pure functions avoiding shared state, mutable data, and side-effects

pure function: a function where with the same input you will get the same output every-time, with no side effects.

higher-order function: a function that takes in another function.

immutable state: where an object can't be changed.

## Preparation Summary
### SQL vs NoSQL
Difference is between the type of the database, SQL is usually a relational database, meaning you have relations (one to many or many to one)

While NoSQL is a non-relational database. Which is also based on a key-value pairs while SQL is based on tables.


### Conceptual Techniques
1- Denormalization

2- Aggregates

3- Application Side Joins

4- Atomic Aggregates

5- Enumerable Keys

6- Dimensionality Reduction

7- Index Table

8- Composite Key Index

9- Aggregation with Composite Keys

10- Inverted Search – Direct Aggregation

11- Tree Aggregation

12- Adjacency Lists

13- Materialized Paths

14- Nested Sets

15- Nested Documents Flattening: Numbered Field Names

16- Nested Documents Flattening: Proximity Queries

17- Batch Graph Processing